<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>编程 on 映屿</title><link>https://www.glowisle.me/tags/%E7%BC%96%E7%A8%8B/</link><description>Recent content in 编程 on 映屿</description><generator>Hugo</generator><language>zh-CN</language><managingEditor>i@glowisle.me (五葉地錦)</managingEditor><webMaster>i@glowisle.me (五葉地錦)</webMaster><lastBuildDate>Sat, 05 Jul 2025 18:32:52 +0000</lastBuildDate><atom:link href="http://www.glowisle.me/tags/%E7%BC%96%E7%A8%8B/atom.xml" rel="self" type="application/rss+xml"/><item><title>C语言的可变参数</title><link>https://www.glowisle.me/posts/c%E8%AF%AD%E8%A8%80%E7%9A%84%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0/</link><pubDate>Sat, 05 Jul 2025 18:32:52 +0000</pubDate><author>i@glowisle.me (五葉地錦)</author><guid>https://www.glowisle.me/posts/c%E8%AF%AD%E8%A8%80%E7%9A%84%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0/</guid><description>&lt;h2 id="介绍"&gt;介绍&lt;/h2&gt;
&lt;p&gt;C语言中，&lt;code&gt;printf()&lt;/code&gt;和&lt;code&gt;scanf()&lt;/code&gt;函数就是典型的变参函数，其优点是灵活处理参数。&lt;/p&gt;
&lt;p&gt;想要创建变参函数需引入头文件&lt;code&gt;stdarg.h&lt;/code&gt;，它有一些宏：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#d6cbb4;background-color:#252b2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;va_list 指向整个可变参数列表的指针
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;原型：typedef char* va_list;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;va_start 指向可变参数列表前的参数（...前的参数）
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;原型：void va_start(va_list ap, paramN);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;va_arg 可变参数列表
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;原型：typedef va_arg(va_list ap, type)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;va_end 结束对可变参数列表的访问，并释放资源
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;原型：void va_end(va_list ap);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id="使用例"&gt;使用例&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#d6cbb4;background-color:#252b2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-c" data-lang="c"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#e67e80"&gt;#include&lt;/span&gt; &lt;span style="color:#e67e80;font-style:italic"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style="color:#e67e80"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#e67e80"&gt;#include&lt;/span&gt; &lt;span style="color:#e67e80;font-style:italic"&gt;&amp;lt;stdarg.h&amp;gt;&lt;/span&gt;&lt;span style="color:#e67e80"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#859289;font-style:italic"&gt;// 定义一个使用省略号的函数原型
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#dbbc7f"&gt;void&lt;/span&gt; &lt;span style="color:#b2c98f"&gt;function&lt;/span&gt;(&lt;span style="color:#dbbc7f"&gt;int&lt;/span&gt; argument, ...)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#859289;font-style:italic"&gt;// 声明一个va_list类型的变量ap，这是可变参数列表
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; va_list ap;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#859289;font-style:italic"&gt;// 使用va_start把变量ap初始化为参数列表
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#b2c98f"&gt;va_start&lt;/span&gt;(ap, argument);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#859289;font-style:italic"&gt;// 第二个参数表明本函数期望传入一个int类型
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#859289;font-style:italic"&gt;// 但是编译器不会检查到底输入了什么。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#dbbc7f"&gt;int&lt;/span&gt; output &lt;span style="color:#7a8478"&gt;=&lt;/span&gt; &lt;span style="color:#b2c98f"&gt;va_arg&lt;/span&gt;(ap, &lt;span style="color:#dbbc7f"&gt;int&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#b2c98f"&gt;printf&lt;/span&gt;(&lt;span style="color:#b2c98f"&gt;&amp;#34;可变参数：%d&lt;/span&gt;&lt;span style="color:#b2c98f"&gt;\n&lt;/span&gt;&lt;span style="color:#b2c98f"&gt;&amp;#34;&lt;/span&gt;, output);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#b2c98f"&gt;va_end&lt;/span&gt;(ap);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#dbbc7f"&gt;int&lt;/span&gt; &lt;span style="color:#b2c98f"&gt;main&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#b2c98f"&gt;function&lt;/span&gt;(&lt;span style="color:#d699b6"&gt;1&lt;/span&gt;, &lt;span style="color:#d699b6"&gt;109&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#d6cbb4;background-color:#252b2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;可变参数：109
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;函数起了作用，但是如果我们需要接受多个参数，应该如何获取呢？&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#d6cbb4;background-color:#252b2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-c" data-lang="c"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#e67e80"&gt;#include&lt;/span&gt; &lt;span style="color:#e67e80;font-style:italic"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style="color:#e67e80"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#e67e80"&gt;#include&lt;/span&gt; &lt;span style="color:#e67e80;font-style:italic"&gt;&amp;lt;stdarg.h&amp;gt;&lt;/span&gt;&lt;span style="color:#e67e80"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#859289;font-style:italic"&gt;// 定义一个使用省略号的函数原型
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#dbbc7f"&gt;void&lt;/span&gt; &lt;span style="color:#b2c98f"&gt;function&lt;/span&gt;(&lt;span style="color:#dbbc7f"&gt;int&lt;/span&gt; argument, ...)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#859289;font-style:italic"&gt;// 声明一个va_list类型的变量ap，这是可变参数列表
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; va_list ap;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#859289;font-style:italic"&gt;// 使用va_start把变量ap初始化为参数列表，此处的第二个参数是最后一个固定参数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#b2c98f"&gt;va_start&lt;/span&gt;(ap, argument);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#859289;font-style:italic"&gt;// 第二个参数表明本函数期望传入一个int类型
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#859289;font-style:italic"&gt;// 但是编译器不会检查到底输入了什么。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#dbbc7f"&gt;int&lt;/span&gt; arguments_list[&lt;span style="color:#d699b6"&gt;4&lt;/span&gt;];
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#e67e80"&gt;for&lt;/span&gt;(&lt;span style="color:#dbbc7f"&gt;int&lt;/span&gt; i &lt;span style="color:#7a8478"&gt;=&lt;/span&gt; &lt;span style="color:#d699b6"&gt;0&lt;/span&gt;; i &lt;span style="color:#7a8478"&gt;&amp;lt;&lt;/span&gt; &lt;span style="color:#d699b6"&gt;4&lt;/span&gt;; i&lt;span style="color:#7a8478"&gt;++&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; arguments_list[i] &lt;span style="color:#7a8478"&gt;=&lt;/span&gt; &lt;span style="color:#b2c98f"&gt;va_arg&lt;/span&gt;(ap, &lt;span style="color:#dbbc7f"&gt;int&lt;/span&gt;); &lt;span style="color:#859289;font-style:italic"&gt;// 按int类型提取参数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#b2c98f"&gt;va_end&lt;/span&gt;(ap);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#859289;font-style:italic"&gt;// 遍历参数列表并打印
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#e67e80"&gt;for&lt;/span&gt; (&lt;span style="color:#dbbc7f"&gt;int&lt;/span&gt; i &lt;span style="color:#7a8478"&gt;=&lt;/span&gt; &lt;span style="color:#d699b6"&gt;0&lt;/span&gt;; i &lt;span style="color:#7a8478"&gt;&amp;lt;&lt;/span&gt; &lt;span style="color:#d699b6"&gt;4&lt;/span&gt;; i&lt;span style="color:#7a8478"&gt;++&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#b2c98f"&gt;printf&lt;/span&gt;(&lt;span style="color:#b2c98f"&gt;&amp;#34;可变参数%d：%d&lt;/span&gt;&lt;span style="color:#b2c98f"&gt;\n&lt;/span&gt;&lt;span style="color:#b2c98f"&gt;&amp;#34;&lt;/span&gt;, i &lt;span style="color:#7a8478"&gt;+&lt;/span&gt; &lt;span style="color:#d699b6"&gt;1&lt;/span&gt;, arguments_list[i]);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#dbbc7f"&gt;int&lt;/span&gt; &lt;span style="color:#b2c98f"&gt;main&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#b2c98f"&gt;function&lt;/span&gt;(&lt;span style="color:#d699b6"&gt;1&lt;/span&gt;, &lt;span style="color:#d699b6"&gt;10&lt;/span&gt;, &lt;span style="color:#d699b6"&gt;12&lt;/span&gt;, &lt;span style="color:#d699b6"&gt;2&lt;/span&gt;, &lt;span style="color:#d699b6"&gt;111&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id="扩展va_start的第二个参数的工作原理"&gt;扩展：&lt;code&gt;va_start&lt;/code&gt;的第二个参数的工作原理&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;va_start&lt;/code&gt;的第二个参数用于定位可变参数列表的起始位置，具体而言，它指向函数参数列表中最后一个固定参数（即省略号前的参数），通过该参数的地址计算出第一个可变参数在内存中的位置。&lt;/p&gt;
&lt;p&gt;C函数的参数按从右至左顺序入栈（栈底高地址，栈顶低地址）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;va_start&lt;/code&gt;的第二个参数作为基准点，其地址加上自身大小后，即指向第一个可变参数的起始地址。&lt;/p&gt;
&lt;p&gt;所以&lt;code&gt;...&lt;/code&gt;前至少要有一个固定参数用于寻址。&lt;/p&gt;</description></item><item><title>面向对象与面向过程的本质区别</title><link>https://www.glowisle.me/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E4%B8%8E%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%BC%96%E7%A8%8B%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%8C%BA%E5%88%AB/</link><pubDate>Thu, 29 May 2025 21:21:36 +0000</pubDate><author>i@glowisle.me (五葉地錦)</author><guid>https://www.glowisle.me/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E4%B8%8E%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%BC%96%E7%A8%8B%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%8C%BA%E5%88%AB/</guid><description>&lt;p&gt;面向对象与面向过程这两种编程思想主要体现在一件事上：面向对象关心&lt;strong&gt;谁来做&lt;/strong&gt;，而面向过程关心&lt;strong&gt;做什么&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;举个例子，如果我现在要开发一个五子棋小游戏，在面向对象的思想中，实现步骤应该是这样的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有一个窗口对象，可以让我的游戏内容展示在里面&lt;/li&gt;
&lt;li&gt;创建棋盘对象&lt;/li&gt;
&lt;li&gt;初始化棋盘&lt;/li&gt;
&lt;li&gt;创建计分板对象&lt;/li&gt;
&lt;li&gt;初始化计分板&lt;/li&gt;
&lt;li&gt;玩家开始下棋，棋盘对象创建棋子对象，绘制出来&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不难看出，面向对象就是在关心&lt;strong&gt;谁来做&lt;/strong&gt;，先关心哪个对象去做，再去研究这个对象要去&lt;strong&gt;怎么做&lt;/strong&gt;。抽象层级更高，但是符合人类的思维。从代码结构上来看，写面向对象更偏向在画一个树状图，一级一级划分谁要做什么事情，而面向过程更像一个线性的流程图，全程都在关心需要做什么事情。&lt;/p&gt;
&lt;p&gt;更官方地说，面向对象以算法和流程为核心，强调步骤拆解。而面向对象以与对象交互为核心，强调责任分配&lt;/p&gt;
&lt;p&gt;当然，写法在语言上就有所限定。C更适合面向过程，头文件的引用使用函数做事就意味着C很难实现面向对象的设计模式，当然有一些比较邪门的技巧，容易开枪把自己脚指头崩掉，比如&lt;code&gt;void*&lt;/code&gt;模拟泛型这种不在本文讨论范围。&lt;/p&gt;
&lt;p&gt;C缺乏类、继承等基础语法支持，但可以用结构体加函数指针简单模拟对象，但设计难度有所增加，调试难度更有所增加。面向过程更适合处理逻辑简单的任务或算法密集型任务，而面向对象更适合构建GUI应用等复杂系统。&lt;/p&gt;
&lt;p&gt;面向对象并非在所有情况下都是最优选择。还是需要依据开发项目的实际需求考量。&lt;/p&gt;</description></item></channel></rss>